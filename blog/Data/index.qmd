
---
title: "Streamlining R Workflows: A Practitioner's Guide to Data Management"
date: today
date-format: medium
categories: [R, Data Management, Tutorial]
tags: [Data, R Programming]
toc: true
---

```{r}
#| label: packages
#| echo: false

library(here)
library(tidyverse)
library(readr)
```

# Introduction

> *If the first line of your R script is*  
> `setwd("C:\\Users\\jenny\\path\\that\\only\\I\\have")`  
> *I will come into your office and SET YOUR COMPUTER ON FIRE ðŸ”¥.*

> *If the first line of your R script is*  
> `rm(list = ls())`  
> *I will come into your office and SET YOUR COMPUTER ON FIRE ðŸ”¥.*

â€” [Jenny Bryan](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)

Data management is a crucial aspect of any data analysis workflow in R. Whether you are a beginner or a seasoned practitioner, effectively renaming variables and managing your datasets can significantly influence your productivity and the clarity of your analysis.

In this guide, we'll explore common methods that users typically employ to rename variables and create labels in R, followed by a more structured and practical approach that can enhance efficiency and maintainability in your data management practices.



## Setting Up Your RStudio Project

Before we dive into data management techniques, it's essential to organize your work efficiently. I recommend starting by creating a new project in RStudio. This will help you manage your files and set a working directory automatically.

1. **Open RStudio**.
2. Go to `File` -> `New Project...`.
3. Choose `New Directory` -> `New Project`.
4. Name your project and select a directory.
5. Click `Create Project`.

With your project set up, you can easily manage your files and scripts, ensuring that your working directory is always pointing to the correct folder.

## Sample Data
Let us create a small sample data

```{r}

# Sample data frame
data <- data.frame(
  id = 1:5,
  age = c(21, 25, 30, 22, 28),
  gender = factor(c("Male", "Female", "Male", "Female", "Female")),
  income = c(50000, 60000, 70000, 80000, 90000),
  education = c(1, 2, 3, 2, 1) # Numeric variable for education
)



```

```{r}
#| eval: false
library(here) # for relative path
# Save the dataset using the here package
write_csv(data, file = here("data", "dummy_data.csv"))
```
This will store our dummy data in the project folder. 

# Traditional Approaches to Data Wrangling

In many data projects, tasks like renaming, dropping, labeling variables, and loading packages are treated as one-off steps scattered across multiple scripts. This can make your workflow hard to follow and difficult to reproduce.

## Dropping some variables
Dropping variables is a key operation in data cleaning. Let us see how we do it

::: {.panel-tabset}
### Base-R

```{r}
#| eval: false
# Drop 'education' column by excluding it
data <- data[, names(data) != "education"]


# Alternatively, keep only specific columns
data <- data[, c("id", "age", "gender", "income")]
``` 

### Tidyverse

```{r}
#| eval: false
library(dplyr)

# Drop 'education' column using dplyr
data <- data %>% select(-education)

# Keep only specific columns
data <- data %>% select(id, age, gender, income)

```
:::

## Renaming 
Renaming variables is essential for clarity and consistency, especially when dealing with raw data that may use cryptic or inconsistent naming conventions, long variable names etc. 

Many users tend to rely on base R functions to rename variables within their data frames. The most common method involves using the `names()` function or `colnames()` function to directly set new variable names. Here's how typical users might approach this task:

```{r}
#| eval: false
colnames(data) <- c("respondent_id", "age", "gender", "income", "education_level")
head(data)
```
a more familiar user of R might prefer using `tidyverse` approach which can be of two methods


Using the `dplyr` package, you can rename variables in two ways: with the `rename()` function or by using the `select()` function. Below is an example of both approaches

:::: {.panel-tabset}

### Using `rename()`

```{r}
#| eval: false
# Load dplyr
library(dplyr)

# Sample data frame
data <- data.frame(
  id = 1:5,
  age = c(21, 25, 30, 22, 28),
  gender = factor(c("Male", "Female", "Male", "Female", "Female")),
  income = c(50000, 60000, 70000, 80000, 90000),
  education = c(1, 2, 3, 2, 1) # Numeric variable for education
)

# Renaming variables using rename()
data <- data %>%
  rename(
    respondent_id = id,
    education_level = education
  )

# Display updated names
head(data)
```

### Using `select()`

```{r}
#| eval: false
# Load dplyr
library(dplyr)

# Sample data frame
data <- data.frame(
  id = 1:5,
  age = c(21, 25, 30, 22, 28),
  gender = factor(c("Male", "Female", "Male", "Female", "Female")),
  income = c(50000, 60000, 70000, 80000, 90000),
  education = c(1, 2, 3, 2, 1) # Numeric variable for education
)

# Renaming variables using select()
data <- data %>%
  select(
    respondent_id = id,
    age,
    gender,
    income,
    education_level = education
  )

# Display updated names
head(data)
```

:::

## Labelling
Variable labels provide descriptive metadata that help users (including future you!) understand the meaning of each variable. This is especially useful in large projects or when preparing data for sharing. R users often overlook the importance of creating labels for their variables. When they do decide to create labels, they typically use the labelled package or similar approaches. Here's how they might go about it:

::: {.panel-tabset}
### Base R (with `Hmisc`)

```{r}
#| eval: false
# install.packages("Hmisc") # if not already installed
library(Hmisc)

label(data$age) <- "Age in years"
label(data$gender) <- "Gender of respondent"
label(data$income) <- "Annual income in USD"
label(data$education) <- "Education level"

```

### Tidyverse (with `labelled`)
```{r}
#| eval: false
# install.packages("labelled") # if not already installed
library(labelled)

data <- data %>%
  set_variable_labels(
    age = "Age in years",
    gender = "Gender of respondent",
    income = "Annual income in USD",
    education = "Education level (1=Primary, 2=Secondary, 3=Tertiary)"
  )

```
:::

# Organizing Workflow: A Practical Take

While the above methods work well and are widely used, they sometimes lack scalability and can lead to messy code, particularly when managing larger datasets or conducting repetitive analyses.

## Setting Up the Environment

The first step in creating a **reproducible working environment in R** is setting up your packages and dependencies in a clean, consistent manner. 

### Why `pacman`?

Over the years, Iâ€™ve tried various strategies to streamline package management â€” including writing custom functions to install and load required libraries. These functions usually looped through a list of package names, checked if they were installed, installed those that were missing, and then loaded them. While this worked, it was often verbose and harder to maintain over time.

Now, I prefer using [`pacman`](https://cran.r-project.org/package=pacman), which offers the same functionality with a cleaner, more robust interface.

```{r}
#| message: false
#| eval: false
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  tidyverse, haven, janitor, labelled, skimr,
  readxl, writexl, here, stringr
)
```
This one-liner installs any missing packages and loads them, eliminating the need to manually manage install.packages() and library() calls â€” and avoids the common practice of commenting out installation lines, which can silently break code for others or even your future self.

My Earlier Approach
Before adopting pacman, I wrote a custom function to do just this â€” install and load a list of packages in a single go. You can view that function here:

[Custom Package Loader Function (GitHub Gist)](https://gist.github.com/nithinmkp/a31b653152b02869a4438d7a73570125)

### Beyond pacman: Full Environment Reproducibility
For long-term and collaborative projects, it's beneficial to complement pacman with tools that enhance reproducibility and robustness â€” such as `renv`, `targets`, and *Docker*.

These tools help manage dependencies, structure workflows, and containerize your environment for seamless collaboration and future-proofing. Iâ€™ll discuss each of them in more detail later.